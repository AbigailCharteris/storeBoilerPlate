// import { expect,assert } from 'chai';
// import connector, {__RewireAPI__ as mock} from '../../../routes/batch/batchConnector'
// import requestBatches from '../../../actions/requestBatchesAction';
// import saveBatch from '../../../actions/saveBatchAction';
// import {SCENARIOS,BATCHES} from '../../../constants/reducerTypes';
// import {SCENARIO_LIST,BATCH_LIST} from '../../../constants/stateConstants';
// import {REQUEST_BATCHES, SAVE_BATCH} from '../../../constants/actionTypes';
// import sinon from 'sinon';

// describe('batchConnector', () => {

//    const FAKE_COMPONENT = {};

//    beforeEach(()=> {
//       mock.__Rewire__('connect', (actualMapStateToProps, actualMapActionsToProps)=> {

//          expect(actualMapActionsToProps).to.deep.equal({
//             [REQUEST_BATCHES]: requestBatches,
//             [SAVE_BATCH]: saveBatch
//          });

//          return (actualComponent)=> {
//             expect(actualComponent).to.deep.equal(FAKE_COMPONENT);

//             return FAKE_COMPONENT;
//          }
//       });

//    });

//    afterEach(()=> {
//       const mockedCollaborators = [
//          'connect'
//       ];

//       mockedCollaborators.forEach(collaborator=>mock.__ResetDependency__);
//    });

//    it('should do nothing if action type is not supported', () => {

//       const actualReducer = connector(FAKE_COMPONENT);

//       expect(actualReducer).to.deep.equal(FAKE_COMPONENT);

//    });

// });
