import { assert, expect } from 'chai';
import sinon from 'sinon';
import { REQUEST_BATCHES_FULFILLED } from '../../constants/actionTypes';

import batchReducer, {
  __RewireAPI__ as mock,
} from '../../reducers/batchReducer';

describe('batchReducer', () => {
  const fromModelMock = sinon.stub();

  beforeEach(() => {
    mock.__Rewire__('fromModel', fromModelMock);
  });

  afterEach(() => {
    mock.__ResetDependency__('fromModel');
  });

  it('should do nothing if action type is not supported', () => {
    const providedState = { existingState: 'test' };
    const providedAction = {
      type: 'CATS',
    };

    const actualReducer = batchReducer(providedState, providedAction);

    expect(actualReducer).to.deep.equal(providedState);
  });

  it('should merge state with action model', () => {
    const fakeActionModel = { miles: 'test' };

    const providedState = { existingState: 'test' };
    const providedAction = {
      type: REQUEST_BATCHES_FULFILLED,
    };

    fromModelMock.withArgs(providedAction).returns(fakeActionModel);

    const actualReducer = batchReducer(providedState, providedAction);

    expect(actualReducer).to.deep.equal({
      existingState: 'test',
      miles: 'test',
    });
  });
});
