import React from 'react';
import ScenarioContainer from './scenarioContainer';
import scenarioConnector from './scenarioConnector';

/*
   This is intended to configure the container.
   For example. ScenarioContainer needs to register the scenarioReducer to obtain scenario data.

   getScenariosEpic is required orchestrate the api calls, and subsequent actions
 */

export default scenarioConnector(ScenarioContainer);
import { AgGridReact, reactCellRendererFactory } from 'ag-grid-react';
import classNames from 'classnames';
import _ from 'lodash';
import PropTypes from 'prop-types';
import React from 'react';
import Rx from 'rxjs';
import Card from 'react-toolbox/lib/card/Card';
import { createSelector } from 'reselect';
import EditScenarioDialog, {
  ADD,
  UPDATE,
} from './scenarios/editScenarioDialog';
import ScenarioAuditDialog from './scenarios/scenarioAuditDialog';
import CheckboxCell, { NODEBINDING } from './scenarios/checkboxCell';
import DownloadCell from './scenarios/downloadCell';
import ScenariosHeader from './scenarios/scenariosHeader';
import formatDate from '../../shared/dateTime';
import GlypIconCell from './scenarios/glypIconCell';
import { CONFIGURATION_STATE } from '../../../services/constants/stateConstants';
import { CAN_EDIT, FILTER } from '../../constants/stateConstants';

const defaultColDef = {
  headerClass: 'scenarios__header-cell',
  cellClass: 'scenarios__cell',
  suppressMenu: true,
};

const getColumnDefs = (
  openEditModal,
  openAuditModal,
  downloadFile,
  settings,
  canEdit
) => {
  const editColumns = canEdit
    ? [
        {
          headerName: '',
          minWidth: 25,
          maxWidth: 25,
          cellClass: 'scenarios__checkbox-cell',
          cellRenderer: reactCellRendererFactory(cellProps => (
            <CheckboxCell
              isSelectedBinding={NODEBINDING}
              isCheckedBindingName="Active"
              field="field"
              cellProps={cellProps}
              className="scenarios__checkbox-cell"
            />
          )),
          suppressSorting: true,
        },
        {
          headerName: ' ',
          minWidth: 25,
          maxWidth: 25,
          cellClass: 'scenarios__icon-cell',
          cellRenderer: reactCellRendererFactory(cellProps => (
            <GlypIconCell
              iconName="edit"
              tooltipText="Edit Scenario"
              onCellClicked={openEditModal}
              cellProps={cellProps}
              className="scenarios__icon-cell"
            />
          )),
          suppressSorting: true,
        },
      ]
    : [];

  return [
    ...editColumns,
    {
      headerName: ' ',
      minWidth: 25,
      maxWidth: 25,
      cellClass: 'scenarios__icon-cell',
      cellRenderer: reactCellRendererFactory(cellProps => (
        <GlypIconCell
          iconName="list-alt"
          tooltipText="Set Active File Version"
          onCellClicked={openAuditModal}
          cellProps={cellProps}
          className="scenarios__icon-cell"
        />
      )),
      suppressSorting: true,
    },
    {
      headerName: ' ',
      field: 'scenarioName',
      cellClass: 'scenarios__download-cell',
      minWidth: 25,
      maxWidth: 25,
      cellRenderer: reactCellRendererFactory(DownloadCell(settings)),
    },
    {
      headerName: 'Scenario Name',
      field: 'scenarioName',
      cellClass: 'scenarios__name-cell',
      minWidth: 200,
    },
    {
      headerName: 'Description',
      field: 'description',
      cellClass: 'scenarios__description-cell',
      minWidth: 400,
    },
    {
      headerName: 'Category',
      field: 'shockClassification',
      cellClass: 'scenarios__description-cell',
      minWidth: 85,
      maxWidth: 85,
    },
    {
      headerName: 'Active File Version',
      field: 'fileVersion',
      cellClass: 'scenario-audit-dialog__updated-cell',
      minWidth: 125,
      maxWidth: 130,
    },
    {
      headerName: 'Updated',
      field: 'updated',
      cellClass: 'scenarios__updated-cell',
      minWidth: 150,
      cellRenderer: ({ value }) => formatDate(value),
    },
    {
      headerName: 'Updated By',
      field: 'updatedBy',
      cellClass: 'scenarios__updatedBy-cell',
      minWidth: 180,
    },
    {
      headerName: '',
      field: 'defaultCol',
      cellClass: 'scenarios__updatedBy-cell',
      minWidth: 10,
      maxWidth: 10,
    },
  ];
};

const createRowData = scenarioList =>
  scenarioList.filter(f => !f.archived).map(scenario => ({
    ...scenario,
    updated: scenario.auditList[scenario.auditList.length - 1].timestamp,
    updatedBy: scenario.auditList[scenario.auditList.length - 1].updatedBy,
  }));

const sortModel = [
  {
    colId: 'updated',
    sort: 'desc',
  },
];

class Scenarios extends React.Component {
  constructor(props) {
    super(props);

    this.closeModal = this.closeModal.bind(this);
    this.deselectAll = this.deselectAll.bind(this);
    this.onSelectionChanged = this.onSelectionChanged.bind(this);
    this.onGridReady = this.onGridReady.bind(this);
    this.openAddModal = this.openAddModal.bind(this);
    this.openEditModal = this.openEditModal.bind(this);
    this.openAuditModal = this.openAuditModal.bind(this);
    this.removeSelected = this.removeSelected.bind(this);
    this.sizeColumnsToFit = _.debounce(this.sizeColumnsToFit.bind(this), 500);
    this.validateScenarioNameCollision = this.validateScenarioNameCollision.bind(
      this
    );
    this.filterColumn = this.filterColumn.bind(this);

    this.getRowData = createSelector(
      state => state.scenarioList,
      createRowData
    );

    this.getColumnDefs = createSelector(
      component => component.openEditModal,
      component => component.openAuditModal,
      component => component.downloadFile,
      state => state.props[CONFIGURATION_STATE],
      state => state.props[CAN_EDIT],
      getColumnDefs
    );

    this._resizeSub = Rx.Observable
      .fromEvent(window, 'resize')
      .subscribe(this.sizeColumnsToFit);

    this.state = {
      isReady: false,
      isModalActive: false,
      isAuditModalActive: false,
      modalMode: ADD,
      modalContext: undefined,
    };
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps[FILTER] || nextProps[FILTER] === '') {
      this.filterColumn(nextProps[FILTER]);
    }
  }

  componentWillUnmount() {
    this.sizeColumnsToFit.cancel();
    this._resizeSub.unsubscribe();
  }

  onGridReady(agGrid) {
    this.agGrid = agGrid;

    this.getRowData(this.props).forEach((row, index) => {
      if (this.props.selectedScenarios[row.id]) {
        agGrid.api.selectIndex(index, true);
      }

      agGrid.api.sizeColumnsToFit();
    });

    agGrid.api.setSortModel(sortModel);
    this.sizeColumnsToFit(() => this.setState({ isReady: true }));
  }

  onSelectionChanged({ selectedRows }) {
    if (this.state.isReady) {
      this.props.selectScenarios({
        value: selectedRows.reduce(
          (value, row) => ({
            ...value,
            [row.id]: true,
          }),
          {}
        ),
      });
    }
  }

  closeModal() {
    this.setState({ isModalActive: false, isAuditModalActive: false });
    this.props.requestScenarios();
    this.props.resetScenarioVersionList();
  }

  deselectAll() {
    this.agGrid.api.deselectAll();
  }

  openAddModal() {
    this.setState({
      isModalActive: true,
      modalMode: ADD,
      modalContext: undefined,
    });
  }

  openAuditModal({ data }) {
    this.props.requestScenarioVersions(data.id);

    this.setState({
      isAuditModalActive: true,
      modalContext: data,
    });
  }

  openEditModal({ data }) {
    this.setState({
      isModalActive: true,
      modalMode: UPDATE,
      modalContext: data,
    });
  }

  removeSelected() {
    const { selectedScenarios } = this.props;
    const scenarioIds = Object.keys(selectedScenarios).filter(
      id => selectedScenarios[id]
    );

    this.props.removeScenario({ scenarioIds });
  }

  sizeColumnsToFit(callback) {
    if (this.agGrid) {
      this.agGrid.api.sizeColumnsToFit();
    }

    if (_.isFunction(callback)) {
      callback();
    }
  }

  validateScenarioNameCollision(scenarioName) {
    let collision = false;

    this.props.scenarioList.forEach(scenario => {
      collision = collision || scenario.scenarioName === scenarioName;
    });

    return collision;
  }

  filterColumn(filterVal) {
    if (!this.agGrid) return;

    this.agGrid.api.setQuickFilter(filterVal);
  }

  render() {
    const rowData = this.getRowData(this.props);
    const columnDefs = this.getColumnDefs(this);

    const {
      className,
      selectedScenarios,
      createScenario,
      removeScenario,
      updateScenario,
      requestScenarioVersions,
      setScenarioVersion,
      scenarioVersionList,
      resetScenarioVersionList,
      requestScenarios,
      busy,
    } = this.props;

    const {
      isReady,
      isModalActive,
      isAuditModalActive,
      modalMode,
      modalContext,
    } = this.state;

    return (
      <div className={classNames('scenarios', className, { busy })}>
        <Card
          className={classNames('ag-fresh ag-grid sc-grid', 'scenarios__card', {
            'scenarios__card--hidden': !isReady,
          })}
        >
          {this.props[CAN_EDIT] && (
            <ScenariosHeader
              selectedScenarios={selectedScenarios}
              add={this.openAddModal}
              deselectAll={this.deselectAll}
              removeSelected={this.removeSelected}
              filterColumn={this.filterColumn}
            />
          )}
          <div className="scenarios__grid-container" style={{ height: '90%' }}>
            <AgGridReact
              columnDefs={columnDefs}
              defaultColDef={defaultColDef}
              enableColResize
              editType="fullRow"
              enableFilter={false}
              enableSorting
              onGridReady={this.onGridReady}
              onRowClicked={this.onRowClicked}
              onSelectionChanged={this.onSelectionChanged}
              rowClass="scenarios__row"
              rowData={rowData}
              rowSelection="multiple"
              suppressContextMenu
              suppressMovableColumns
              suppressRowClickSelection
            />
          </div>
        </Card>
        {this.props[CAN_EDIT] && (
          <EditScenarioDialog
            active={isModalActive}
            mode={modalMode}
            scenario={modalContext}
            createScenario={createScenario}
            removeScenario={removeScenario}
            updateScenario={updateScenario}
            validateScenarioNameCollision={this.validateScenarioNameCollision}
            onClose={this.closeModal}
          />
        )}
        <ScenarioAuditDialog
          active={isAuditModalActive}
          mode={modalMode}
          scenario={modalContext}
          scenarioVersionList={scenarioVersionList}
          requestScenarioVersions={requestScenarioVersions}
          requestScenarios={requestScenarios}
          setScenarioVersion={setScenarioVersion}
          {...{ [CAN_EDIT]: this.props[CAN_EDIT] }}
          resetScenarioVersionList={resetScenarioVersionList}
          onClose={this.closeModal}
        />
      </div>
    );
  }
}

Scenarios.propTypes = {
  className: PropTypes.string,
  scenarioList: PropTypes.arrayOf(PropTypes.object).isRequired,
  scenarioVersionList: PropTypes.arrayOf(PropTypes.object).isRequired,
  selectedScenarios: PropTypes.objectOf(PropTypes.bool).isRequired,
  selectScenarios: PropTypes.func.isRequired,
  createScenario: PropTypes.func.isRequired,
  removeScenario: PropTypes.func.isRequired,
  updateScenario: PropTypes.func.isRequired,
  requestScenarioVersions: PropTypes.func.isRequired,
  requestScenarios: PropTypes.func.isRequired,
  setScenarioVersion: PropTypes.func.isRequired,
  resetScenarioVersionList: PropTypes.func.isRequired,
  [CAN_EDIT]: PropTypes.bool.isRequired,
  busy: PropTypes.bool,
  [FILTER]: PropTypes.string.isRequired,
};

Scenarios.defaultProps = {
  [FILTER]: '',
  className: '',
  busy: false,
};

export default Scenarios;
